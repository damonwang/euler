from itertools import islice
import numpy as np 
import unittest 

from euler12 import eratosthenes

'''
If our quadratic is
    q(n) = n^2 + an + b
then q(0) is prime implies that b be prime
and q(1) is prime implies that a - b -1 be prime

If |a|, |b| < 1000, then q(0) < 1000 and q(1) < 2000.

There are 168 primes below 1000 and each specifies a unique candidate for b. 

There are 303 primes p below 2000, and each pair (b, p) specifies a unique
candidate for a.

So at most, there are 168 * 303 = 50904 pairs of a, b to check.

Assume some reasonable bound, like 1000, on the number of primes which can be
generated by a single quadratic q. 

These bounds on a, b, and n imply q(n) < 3e6. Say 4e6, just to be safe.

The fastest way to check primality of numbers in the 10^6 range is to enumerate
them all with a sieve.
'''

primes = islice(

is_prime = np.zeros((200

def run_tests(verbosity=0, tests=[]):
    tests = [ unittest.TestLoader().loadTestsFromTestCase(v)
            for k,v in globals().items()
            if k.startswith("Test") and (tests == [] or k in tests)]
    unittest.TextTestRunner(verbosity=verbosity).run(unittest.TestSuite(tests))

if __name__ == '__main__':

    run_tests()
