from itertools import islice, takewhile, count
from operator import itemgetter, mul
import numpy as np 
import unittest 
import os
from os import path

import pyximport
pyximport.install()

import eratosthenes

__cache__ = 'cache.npy'

'''
If our quadratic is
    q(n) = n^2 + an + b
then q(0) is prime implies that b be prime
and q(1) is prime implies that a - b -1 be prime

If |a|, |b| < 1000, then q(0) < 1000 and q(1) < 2000.

There are 168 primes below 1000 and each specifies a unique candidate for b. 

There are 303 primes p below 2000, and each pair (b, p) specifies a unique
candidate for a.

So at most, there are 168 * 303 = 50904 pairs of a, b to check.

Assume some reasonable bound, like 1000, on the number of primes which can be
generated by a single quadratic q. 

These bounds on a, b, and n imply q(n) < 3e6. Say 4e6, just to be safe.

The fastest way to check primality of numbers in the 10^6 range is to enumerate
them all with a sieve.
'''


if path.exists(__cache__):
    primes = np.load(__cache__)
    is_prime = np.zeros((5e6), dtype='bool')
    is_prime[primes] = True
else:
    is_prime = np.ones((5e6), dtype='int8')
    eratosthenes.sieve(is_prime)
    is_prime.dtype = 'bool'
    primes = np.where(is_prime)[0]
    np.save(__cache__, primes)

def candidates(max_a, max_b):
    '''
    candidates(int max_a=1000, int max_b=1000) yields (int, int)

    Given the bounds |a| < max_a and |b| < max_b, yields candidates for
    (a, b) as described above.
    '''

    for b in takewhile(lambda x: x < max_b, primes):
        for q in takewhile(lambda x: x < 1 + max_a + b, primes):
            yield (q - 1 - b, b)

def take(n, seq):
    '''
    take(n, iterable seq) yields item

    yields the first n items of iterable seq
    '''

    return takewhile(lambda x, i=count(): next(i) < n, seq)

def iterlen(seq):
    '''
    iterlen(iterable seq) -> int

    destructively returns the length of an iterator. NOT safe for infinite generators.
    '''

    rv = 0
    for i in seq:
        rv += 1
    return rv

def score(a, b):
    '''
    score(int a, int b) -> int

    returns max N s.t. for all n in 0..N, n^2 + an + b is prime.
    '''

    rv = iterlen(takewhile(lambda n: is_prime[n*n + a*n + b], count()))
    assert rv > 1
    return rv

def solve(max_a=1000, max_b=1000):

    rv = [ (a, b, score(a, b)) for a, b in candidates(max_a, max_b) ]
    coeffs = max(*rv, key=itemgetter(2))[:2]
    return reduce(mul, coeffs)

def run_tests(verbosity=0, tests=[]):
    tests = [ unittest.TestLoader().loadTestsFromTestCase(v)
            for k,v in globals().items()
            if k.startswith("Test") and (tests == [] or k in tests)]
    unittest.TextTestRunner(verbosity=verbosity).run(unittest.TestSuite(tests))

if __name__ == '__main__':

    run_tests()
